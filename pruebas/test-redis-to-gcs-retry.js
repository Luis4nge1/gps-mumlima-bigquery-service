import { RedisRepository } from '../src/repositories/RedisRepository.js';
import { GCSAdapter } from '../src/adapters/GCSAdapter.js';
import { BackupManager } from '../src/utils/BackupManager.js';
import dotenv from 'dotenv';

dotenv.config();

/**
 * Prueba del flujo Redis ‚Üí GCS con simulaci√≥n de fallos y reintentos
 * Verifica que el sistema maneja correctamente los fallos y reintenta la subida
 */
async function testRedisToGCSWithRetries() {
    console.log('üîÑ Probando flujo Redis ‚Üí GCS con simulaci√≥n de fallos y reintentos');
    console.log('üìã Usando keys: gps:history:global y mobile:history:global\n');
    
    let redisRepo, gcsAdapter, backupManager;
    
    try {
        // 1. Inicializar servicios
        console.log('üìã Paso 1: Inicializando servicios...');
        redisRepo = new RedisRepository();
        gcsAdapter = new GCSAdapter();
        backupManager = new BackupManager();
        
        await redisRepo.initialize();
        console.log('‚úÖ Redis inicializado');
        console.log('‚úÖ GCS Adapter listo');
        console.log('‚úÖ Backup Manager listo');
        
        // 2. Agregar datos de prueba a Redis
        console.log('\nüìã Paso 2: Agregando datos de prueba a Redis...');
        await addTestDataToRedis(redisRepo);
        
        // 3. Simular fallo en GCS y crear backup local
        console.log('\nüîÑ === SIMULANDO FALLO EN GCS ===');
        await simulateGCSFailureAndBackup(redisRepo, gcsAdapter, backupManager);
        
        // 4. Verificar backups pendientes
        console.log('\nüìä === VERIFICANDO BACKUPS PENDIENTES ===');
        await verifyPendingBackups(backupManager);
        
        // 5. Simular reintentos con fallos parciales
        console.log('\nüîÑ === SIMULANDO REINTENTOS CON FALLOS ===');
        await simulateRetriesWithPartialFailures(backupManager, gcsAdapter);
        
        // 6. Reintento exitoso final
        console.log('\n‚úÖ === REINTENTO EXITOSO FINAL ===');
        await simulateSuccessfulRetry(backupManager, gcsAdapter);
        
        // 7. Verificar estado final
        console.log('\nüìä === VERIFICACI√ìN FINAL ===');
        await verifyFinalState(redisRepo, gcsAdapter, backupManager);
        
        console.log('\nüéâ ¬°Prueba de reintentos Redis ‚Üí GCS completada exitosamente!');
        
    } catch (error) {
        console.error('‚ùå Error en la prueba:', error);
        console.error('Stack trace:', error.stack);
    } finally {
        console.log('\nüîå Cerrando conexiones...');
        if (redisRepo) await redisRepo.disconnect();
        if (gcsAdapter) await gcsAdapter.cleanup();
        process.exit(0);
    }
}

async function addTestDataToRedis(redisRepo) {
    try {
        // Datos GPS de prueba
        const gpsTestData = [
            {
                deviceId: 'GPS_RETRY_001',
                timestamp: new Date().toISOString(),
                lat: -12.0464,
                lng: -77.0428,
                testType: 'retry_simulation'
            },
            {
                deviceId: 'GPS_RETRY_002',
                timestamp: new Date(Date.now() - 30000).toISOString(),
                lat: -12.0500,
                lng: -77.0450,
                testType: 'retry_simulation'
            }
        ];
        
        // Datos Mobile de prueba
        const mobileTestData = [
            {
                userId: 'USER_RETRY_001',
                timestamp: new Date().toISOString(),
                lat: -12.0464,
                lng: -77.0428,
                name: 'Inspector Retry Test',
                email: 'retry.test@lima.gob.pe',
                testType: 'retry_simulation'
            }
        ];
        
        const gpsKey = 'gps:history:global';
        const mobileKey = 'mobile:history:global';
        
        console.log(`üìù Agregando ${gpsTestData.length} registros GPS a: ${gpsKey}`);
        await redisRepo.addMultipleToList(gpsKey, gpsTestData);
        
        console.log(`üìù Agregando ${mobileTestData.length} registros Mobile a: ${mobileKey}`);
        await redisRepo.addMultipleToList(mobileKey, mobileTestData);
        
        const gpsCount = await redisRepo.getListLength(gpsKey);
        const mobileCount = await redisRepo.getListLength(mobileKey);
        
        console.log(`‚úÖ GPS en Redis: ${gpsCount} registros`);
        console.log(`‚úÖ Mobile en Redis: ${mobileCount} registros`);
        
    } catch (error) {
        console.error('‚ùå Error agregando datos de prueba:', error.message);
        throw error;
    }
}

async function simulateGCSFailureAndBackup(redisRepo, gcsAdapter, backupManager) {
    try {
        const gpsKey = 'gps:history:global';
        const mobileKey = 'mobile:history:global';
        
        // Obtener datos de Redis
        const gpsData = await redisRepo.getListData(gpsKey);
        const mobileData = await redisRepo.getListData(mobileKey);
        
        console.log(`üì¶ Obtenidos ${gpsData.length} registros GPS y ${mobileData.length} registros Mobile`);
        
        // Simular fallo en GCS creando un mock que siempre falla
        const originalUploadJSONLines = gcsAdapter.uploadJSONLines;
        let failureCount = 0;
        
        gcsAdapter.uploadJSONLines = async (jsonLines, fileName, metadata) => {
            failureCount++;
            console.log(`üí• Simulando fallo ${failureCount} en GCS upload: ${fileName}`);
            return {
                success: false,
                error: `Simulated GCS failure #${failureCount}: Network timeout`,
                fileName
            };
        };
        
        // Intentar procesar GPS (fallar√° y crear√° backup)
        console.log('\nüîÑ Procesando datos GPS (simulando fallo)...');
        const gpsBackupResult = await processDataWithFailureHandling(
            gpsData, 'gps', gcsAdapter, backupManager, 'gps-data/'
        );
        
        if (gpsBackupResult.backupCreated) {
            console.log(`‚úÖ Backup GPS creado: ${gpsBackupResult.backupId}`);
        }
        
        // Intentar procesar Mobile (fallar√° y crear√° backup)
        console.log('\nüîÑ Procesando datos Mobile (simulando fallo)...');
        const mobileBackupResult = await processDataWithFailureHandling(
            mobileData, 'mobile', gcsAdapter, backupManager, 'mobile-data/'
        );
        
        if (mobileBackupResult.backupCreated) {
            console.log(`‚úÖ Backup Mobile creado: ${mobileBackupResult.backupId}`);
        }
        
        // Limpiar datos de Redis ya que se crearon backups
        console.log('\nüóëÔ∏è Limpiando datos de Redis despu√©s de crear backups...');
        await redisRepo.clearListData(gpsKey);
        await redisRepo.clearListData(mobileKey);
        console.log('‚úÖ Datos limpiados de Redis');
        
        // Restaurar funci√≥n original
        gcsAdapter.uploadJSONLines = originalUploadJSONLines;
        
    } catch (error) {
        console.error('‚ùå Error simulando fallo en GCS:', error.message);
        throw error;
    }
}

async function processDataWithFailureHandling(data, type, gcsAdapter, backupManager, gcsPrefix) {
    try {
        if (data.length === 0) {
            console.log(`‚ö†Ô∏è No hay datos ${type} para procesar`);
            return { backupCreated: false };
        }
        
        // Crear nombre de archivo
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const processingId = `${type}_retry_test_${Date.now()}`;
        const fileName = `${gcsPrefix}${timestamp}_${processingId}.json`;
        
        // Convertir a JSON Lines
        const jsonLines = data.map(item => JSON.stringify(item)).join('\n');
        
        console.log(`üì§ Intentando subir archivo ${type}: ${fileName}`);
        
        // Intentar subir a GCS (fallar√° por el mock)
        const gcsResult = await gcsAdapter.uploadJSONLines(jsonLines, fileName, {
            dataType: type,
            processingId: processingId,
            recordCount: data.length,
            sourceKey: `${type}:history:global`
        });
        
        if (!gcsResult.success) {
            console.log(`üí• Fallo en GCS como esperado: ${gcsResult.error}`);
            
            // Crear backup local
            console.log(`üíæ Creando backup local para ${type}...`);
            const backupResult = await backupManager.saveToLocalBackup(data, type, {
                originalFailureReason: gcsResult.error,
                originalFileName: fileName,
                processingId: processingId
            });
            
            if (backupResult.success) {
                console.log(`‚úÖ Backup local creado: ${backupResult.backupId}`);
                return {
                    backupCreated: true,
                    backupId: backupResult.backupId,
                    filePath: backupResult.filePath
                };
            } else {
                throw new Error(`Error creando backup: ${backupResult.error}`);
            }
        }
        
        return { backupCreated: false };
        
    } catch (error) {
        console.error(`‚ùå Error procesando datos ${type}:`, error.message);
        throw error;
    }
}

async function verifyPendingBackups(backupManager) {
    try {
        const pendingBackups = await backupManager.getLocalBackupFiles();
        
        console.log(`üìã Backups pendientes encontrados: ${pendingBackups.length}`);
        
        for (const backup of pendingBackups) {
            console.log(`üìÑ Backup: ${backup.id}`);
            console.log(`   Tipo: ${backup.type}`);
            console.log(`   Registros: ${backup.data?.length || 0}`);
            console.log(`   Reintentos: ${backup.metadata.retryCount}/${backup.metadata.maxRetries}`);
            console.log(`   Estado: ${backup.status}`);
            console.log(`   Edad: ${Math.round((Date.now() - new Date(backup.timestamp).getTime()) / 1000)}s`);
        }
        
        if (pendingBackups.length === 0) {
            console.log('‚ö†Ô∏è No se encontraron backups pendientes');
        }
        
    } catch (error) {
        console.error('‚ùå Error verificando backups pendientes:', error.message);
        throw error;
    }
}

async function simulateRetriesWithPartialFailures(backupManager, gcsAdapter) {
    try {
        const pendingBackups = await backupManager.getLocalBackupFiles();
        
        if (pendingBackups.length === 0) {
            console.log('‚ö†Ô∏è No hay backups pendientes para reintentar');
            return;
        }
        
        // Crear mock que falla las primeras 2 veces, luego tiene √©xito
        let attemptCount = 0;
        const originalUploadJSONLines = gcsAdapter.uploadJSONLines;
        
        gcsAdapter.uploadJSONLines = async (jsonLines, fileName, metadata) => {
            attemptCount++;
            
            if (attemptCount <= 2) {
                console.log(`üí• Simulando fallo ${attemptCount}/2 en reintento: ${fileName}`);
                return {
                    success: false,
                    error: `Simulated retry failure #${attemptCount}: Connection refused`,
                    fileName
                };
            } else {
                console.log(`‚úÖ Simulando √©xito en intento ${attemptCount}: ${fileName}`);
                // Llamar a la funci√≥n original para simular √©xito real
                return await originalUploadJSONLines.call(gcsAdapter, jsonLines, fileName, metadata);
            }
        };
        
        // Funci√≥n mock para upload que simula el comportamiento real
        const mockGcsUpload = async (data, type) => {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const processingId = `retry_success_${Date.now()}`;
            const fileName = `${type}-data/${timestamp}_${processingId}.json`;
            const jsonLines = data.map(item => JSON.stringify(item)).join('\n');
            
            return await gcsAdapter.uploadJSONLines(jsonLines, fileName, {
                dataType: type,
                processingId: processingId,
                recordCount: data.length,
                retryAttempt: true
            });
        };
        
        // Procesar cada backup pendiente
        for (const backup of pendingBackups) {
            console.log(`\nüîÑ Procesando backup: ${backup.id} (${backup.type})`);
            
            // Simular 2 fallos seguidos
            for (let i = 1; i <= 2; i++) {
                console.log(`\n   Intento ${i + backup.metadata.retryCount}/3:`);
                
                const result = await backupManager.processLocalBackupFile(backup, mockGcsUpload);
                
                if (result.success) {
                    console.log(`   ‚úÖ √âxito inesperado en intento ${i}`);
                    break;
                } else {
                    console.log(`   üí• Fallo esperado: ${result.error}`);
                    console.log(`   üìä Reintentos: ${result.retryCount}/${result.maxRetries}`);
                    console.log(`   üîÑ Reintentar√°: ${result.willRetry ? 'S√≠' : 'No'}`);
                }
                
                // Peque√±a pausa entre reintentos
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
        }
        
        // Restaurar funci√≥n original
        gcsAdapter.uploadJSONLines = originalUploadJSONLines;
        
    } catch (error) {
        console.error('‚ùå Error simulando reintentos con fallos:', error.message);
        throw error;
    }
}

async function simulateSuccessfulRetry(backupManager, gcsAdapter) {
    try {
        const pendingBackups = await backupManager.getLocalBackupFiles();
        
        console.log(`üìã Backups pendientes para reintento final: ${pendingBackups.length}`);
        
        if (pendingBackups.length === 0) {
            console.log('‚úÖ No hay backups pendientes, todos fueron procesados');
            return;
        }
        
        // Funci√≥n de upload que siempre tiene √©xito
        const successfulGcsUpload = async (data, type) => {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const processingId = `final_success_${Date.now()}`;
            const fileName = `${type}-data/${timestamp}_${processingId}.json`;
            const jsonLines = data.map(item => JSON.stringify(item)).join('\n');
            
            console.log(`‚òÅÔ∏è Subiendo exitosamente: ${fileName}`);
            
            const result = await gcsAdapter.uploadJSONLines(jsonLines, fileName, {
                dataType: type,
                processingId: processingId,
                recordCount: data.length,
                finalRetryAttempt: true
            });
            
            if (result.success) {
                console.log(`‚úÖ Upload exitoso: ${result.gcsUri}`);
            }
            
            return result;
        };
        
        // Procesar todos los backups pendientes
        for (const backup of pendingBackups) {
            console.log(`\nüîÑ Reintento final para backup: ${backup.id} (${backup.type})`);
            console.log(`   Registros: ${backup.data?.length || 0}`);
            console.log(`   Reintentos previos: ${backup.metadata.retryCount}/${backup.metadata.maxRetries}`);
            
            const result = await backupManager.processLocalBackupFile(backup, successfulGcsUpload);
            
            if (result.success) {
                console.log(`‚úÖ Backup procesado exitosamente: ${backup.id}`);
                console.log(`   üìÅ Archivo GCS: ${result.gcsFile}`);
                console.log(`   üìä Registros procesados: ${result.recordsProcessed}`);
                console.log(`   üîÑ Intento final: ${result.attempt}`);
                console.log(`   ‚è±Ô∏è Duraci√≥n upload: ${result.uploadDuration}ms`);
                console.log(`   ‚è±Ô∏è Duraci√≥n total: ${result.totalDuration}ms`);
            } else {
                console.log(`‚ùå Backup fall√≥ definitivamente: ${backup.id}`);
                console.log(`   Error: ${result.error}`);
                console.log(`   Reintentos: ${result.retryCount}/${result.maxRetries}`);
            }
        }
        
    } catch (error) {
        console.error('‚ùå Error en reintento exitoso final:', error.message);
        throw error;
    }
}

async function verifyFinalState(redisRepo, gcsAdapter, backupManager) {
    try {
        console.log('üîç Verificando estado final despu√©s de reintentos...');
        
        // Verificar Redis
        const gpsKey = 'gps:history:global';
        const mobileKey = 'mobile:history:global';
        
        const gpsRemaining = await redisRepo.getListLength(gpsKey);
        const mobileRemaining = await redisRepo.getListLength(mobileKey);
        
        console.log(`üìä Redis GPS restantes: ${gpsRemaining}`);
        console.log(`üìä Redis Mobile restantes: ${mobileRemaining}`);
        
        // Verificar backups pendientes
        const pendingBackups = await backupManager.getLocalBackupFiles();
        console.log(`üìã Backups pendientes restantes: ${pendingBackups.length}`);
        
        // Verificar GCS
        const bucketStats = await gcsAdapter.getBucketStats();
        console.log(`‚òÅÔ∏è Total archivos en GCS: ${bucketStats.totalFiles}`);
        console.log(`üíæ Tama√±o total GCS: ${Math.round(bucketStats.totalSize / 1024)} KB`);
        console.log(`üìÅ Archivos por tipo:`, bucketStats.filesByType);
        
        // Verificar conexi√≥n Redis
        const redisConnected = await redisRepo.ping();
        console.log(`üîó Redis conectado: ${redisConnected ? '‚úÖ' : '‚ùå'}`);
        
        // Mostrar resumen de la prueba
        console.log('\nüìä === RESUMEN DE LA PRUEBA ===');
        console.log('‚úÖ Simulaci√≥n de fallos en GCS: Completada');
        console.log('‚úÖ Creaci√≥n de backups locales: Completada');
        console.log('‚úÖ Reintentos con fallos parciales: Completada');
        console.log('‚úÖ Reintento exitoso final: Completada');
        console.log(`üìã Backups procesados exitosamente: ${pendingBackups.length === 0 ? 'Todos' : 'Parcial'}`);
        
    } catch (error) {
        console.error('‚ùå Error verificando estado final:', error.message);
    }
}

// Ejecutar la prueba
testRedisToGCSWithRetries();